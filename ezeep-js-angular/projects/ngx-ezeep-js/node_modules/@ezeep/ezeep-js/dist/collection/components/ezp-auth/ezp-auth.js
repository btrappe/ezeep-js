import { Component, Host, h, Prop, State, Event } from '@stencil/core';
import { EzpAuthorizationService } from '../../services/auth';
import authStore from '../../services/auth';
import i18next from 'i18next';
import { initi18n } from '../../utils/utils';
export class EzpAuth {
  constructor() {
    this.windowObjectReference = null;
    this.previousUrl = null;
    this.handleCancel = () => {
      this.authCancel.emit();
    };
  }
  openSignInWindow(url, name) {
    // remove any existing event listeners
    window.removeEventListener('message', this.receiveMessage);
    // window features
    const strWindowFeatures = 'toolbar=no, menubar=no, width=600, height=7000, top=100, left=100';
    if (this.windowObjectReference === null || this.windowObjectReference.closed) {
      /* if the pointer to the window object in memory does not exist
      or if such pointer exists but the window was closed */
      this.windowObjectReference = window.open(url, name, strWindowFeatures);
    }
    else if (this.previousUrl !== this.auth.authURI.toString()) {
      /* if the resource to load is different,
      then we load it in the already opened secondary window and then
      we bring such window back on top/in front of its parent window. */
      this.windowObjectReference = window.open(url, name, strWindowFeatures);
      this.windowObjectReference.focus();
    }
    else {
      /* else the window reference must exist and the window
     is not closed; therefore, we can bring it back on top of any other
     window with the focus() method. There would be no need to re-create
     the window or to reload the referenced resource. */
      this.windowObjectReference.focus();
    }
    // check if the window was closed and cancel login accordingly
    if (this.hidelogin) {
      let checkClosedTimer = setInterval(() => {
        if (this.windowObjectReference.closed) {
          this.handleCancel();
          clearInterval(checkClosedTimer);
        }
      }, 500);
    }
    // add the listener for receiving a message from the popup
    window.addEventListener('message', (event) => this.receiveMessage(event), false);
    this.previousUrl = this.auth.authURI;
  }
  receiveMessage(event) {
    this.auth.code = event.data;
    this.auth.getAccessToken().finally(() => {
      this.authCancel.emit();
      this.printShow.emit();
    });
  }
  async componentWillLoad() {
    initi18n();
    this.auth = new EzpAuthorizationService(this.redirectURI, this.clientID);
    if (authStore.state.isAuthorized === false) {
      this.auth.generateCodeVerifier();
      await this.auth.generateCodeChallenge(authStore.state.codeVerifier);
      this.auth.buildAuthURI();
    }
    if (this.hidelogin) {
      this.openSignInWindow(this.auth.authURI.toString(), 'ezeep Login');
    }
  }
  render() {
    return this.hidelogin ? (h("ezp-progress", { status: i18next.t('login_page.login') })) : (h(Host, null,
      h("div", { id: "dialog" },
        h("div", { id: "header" },
          h("ezp-icon-button", { onClick: this.handleCancel, icon: "cross", level: "tertiary" })),
        h("div", { id: "content" },
          h("ezp-icon", { id: "icon", name: "rocket", size: "large" }),
          h("ezp-label", { level: "primary", weight: "heavy", text: i18next.t('login_page.get_started') }),
          h("ezp-label", { text: i18next.t('login_page.description') }),
          h("ezp-text-button", { label: i18next.t('login_page.login'), id: "button", onClick: () => {
              this.openSignInWindow(this.auth.authURI.toString(), 'ezeep Login');
            } })))));
  }
  static get is() { return "ezp-auth"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["ezp-auth.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["ezp-auth.css"]
  }; }
  static get properties() { return {
    "clientID": {
      "type": "string",
      "mutable": true,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "client-i-d",
      "reflect": false
    },
    "redirectURI": {
      "type": "string",
      "mutable": true,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "redirect-u-r-i",
      "reflect": false
    },
    "hidelogin": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "hidelogin",
      "reflect": false
    }
  }; }
  static get states() { return {
    "auth": {},
    "authURI": {},
    "accessToken": {}
  }; }
  static get events() { return [{
      "method": "authCancel",
      "name": "authCancel",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": ""
      },
      "complexType": {
        "original": "MouseEvent",
        "resolved": "MouseEvent",
        "references": {
          "MouseEvent": {
            "location": "global"
          }
        }
      }
    }, {
      "method": "printShow",
      "name": "printShow",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": ""
      },
      "complexType": {
        "original": "any",
        "resolved": "any",
        "references": {}
      }
    }]; }
}
